<?php
/**
 * BundleApi
 * PHP version 5
 *
 * @category Class
 * @package  iNew\Rest6_1
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Open REST API
 *
 * The Open REST API provides all available methods for integrators to access the I-New platform
 *
 * OpenAPI spec version: 6.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace iNew\Rest6_1\Api;

use \iNew\Rest6_1\ApiClient;
use \iNew\Rest6_1\ApiException;
use \iNew\Rest6_1\Configuration;
use \iNew\Rest6_1\ObjectSerializer;

/**
 * BundleApi Class Doc Comment
 *
 * @category Class
 * @package  iNew\Rest6_1
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class BundleApi
{
    /**
     * API Client
     *
     * @var \iNew\Rest6_1\ApiClient instance of the ApiClient
     */
    protected $apiClient;

    /**
     * Constructor
     *
     * @param \iNew\Rest6_1\ApiClient|null $apiClient The api client to use
     */
    public function __construct(\iNew\Rest6_1\ApiClient $apiClient = null)
    {
        if ($apiClient === null) {
            $apiClient = new ApiClient();
        }

        $this->apiClient = $apiClient;
    }

    /**
     * Get API client
     *
     * @return \iNew\Rest6_1\ApiClient get the API client
     */
    public function getApiClient()
    {
        return $this->apiClient;
    }

    /**
     * Set the API client
     *
     * @param \iNew\Rest6_1\ApiClient $apiClient set the API client
     *
     * @return BundleApi
     */
    public function setApiClient(\iNew\Rest6_1\ApiClient $apiClient)
    {
        $this->apiClient = $apiClient;
        return $this;
    }

    /**
     * Operation crceBundleAdministrationActivate
     *
     * activates the given bundle
     *
     * @param int $customer_account_id field used to represent the customer identifier, this request is intended for (required)
     * @param int $subscription_id the subscription id (required)
     * @param string $bundle_code the bundle code identifying the bundle that should be activated (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $pin the customer pin, is needed if the customer has enabled security and the request comes from self care (if left empty will not be verified, except for Online Payment use cases) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param int $opp_id the online payment profile ID to use for the payment, if not provided the main balance (e.g. of the prepaid account) will be used for the payment (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return \iNew\Rest6_1\Model\ActivateBundleResponse
     */
    public function crceBundleAdministrationActivate($customer_account_id, $subscription_id, $bundle_code, $correlation_id = null, $pin = null, $transaction_id = null, $user = null, $opp_id = null)
    {
        list($response) = $this->crceBundleAdministrationActivateWithHttpInfo($customer_account_id, $subscription_id, $bundle_code, $correlation_id, $pin, $transaction_id, $user, $opp_id);
        return $response;
    }

    /**
     * Operation crceBundleAdministrationActivateWithHttpInfo
     *
     * activates the given bundle
     *
     * @param int $customer_account_id field used to represent the customer identifier, this request is intended for (required)
     * @param int $subscription_id the subscription id (required)
     * @param string $bundle_code the bundle code identifying the bundle that should be activated (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $pin the customer pin, is needed if the customer has enabled security and the request comes from self care (if left empty will not be verified, except for Online Payment use cases) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param int $opp_id the online payment profile ID to use for the payment, if not provided the main balance (e.g. of the prepaid account) will be used for the payment (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return array of \iNew\Rest6_1\Model\ActivateBundleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function crceBundleAdministrationActivateWithHttpInfo($customer_account_id, $subscription_id, $bundle_code, $correlation_id = null, $pin = null, $transaction_id = null, $user = null, $opp_id = null)
    {
        // verify the required parameter 'customer_account_id' is set
        if ($customer_account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $customer_account_id when calling crceBundleAdministrationActivate');
        }
        // verify the required parameter 'subscription_id' is set
        if ($subscription_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $subscription_id when calling crceBundleAdministrationActivate');
        }
        // verify the required parameter 'bundle_code' is set
        if ($bundle_code === null) {
            throw new \InvalidArgumentException('Missing the required parameter $bundle_code when calling crceBundleAdministrationActivate');
        }
        // parse inputs
        $resourcePath = "/customers/{customerAccountId}/subscriptions/{subscriptionId}/availableBundles/{bundleCode}/activate";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($opp_id !== null) {
            $queryParams['oppId'] = $this->apiClient->getSerializer()->toQueryValue($opp_id);
        }
        // header params
        if ($correlation_id !== null) {
            $headerParams['correlationId'] = $this->apiClient->getSerializer()->toHeaderValue($correlation_id);
        }
        // header params
        if ($pin !== null) {
            $headerParams['pin'] = $this->apiClient->getSerializer()->toHeaderValue($pin);
        }
        // header params
        if ($transaction_id !== null) {
            $headerParams['transactionId'] = $this->apiClient->getSerializer()->toHeaderValue($transaction_id);
        }
        // header params
        if ($user !== null) {
            $headerParams['user'] = $this->apiClient->getSerializer()->toHeaderValue($user);
        }
        // path params
        if ($customer_account_id !== null) {
            $resourcePath = str_replace(
                "{" . "customerAccountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($customer_account_id),
                $resourcePath
            );
        }
        // path params
        if ($subscription_id !== null) {
            $resourcePath = str_replace(
                "{" . "subscriptionId" . "}",
                $this->apiClient->getSerializer()->toPathValue($subscription_id),
                $resourcePath
            );
        }
        // path params
        if ($bundle_code !== null) {
            $resourcePath = str_replace(
                "{" . "bundleCode" . "}",
                $this->apiClient->getSerializer()->toPathValue($bundle_code),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('accessKey');
        if (strlen($apiKey) !== 0) {
            $headerParams['accessKey'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\iNew\Rest6_1\Model\ActivateBundleResponse',
                '/customers/{customerAccountId}/subscriptions/{subscriptionId}/availableBundles/{bundleCode}/activate'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\iNew\Rest6_1\Model\ActivateBundleResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\ActivateBundleResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation crceBundleAdministrationActivateSubscription
     *
     * activates the given bundle
     *
     * @param int $subscription_id the subscription id (required)
     * @param string $bundle_code the bundle code identifying the bundle that should be activated (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $pin the customer pin, is needed if the customer has enabled security and the request comes from self care (if left empty will not be verified, except for Online Payment use cases) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param int $opp_id the online payment profile ID to use for the payment, if not provided the main balance (e.g. of the prepaid account) will be used for the payment (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return \iNew\Rest6_1\Model\ActivateBundleResponse
     */
    public function crceBundleAdministrationActivateSubscription($subscription_id, $bundle_code, $correlation_id = null, $pin = null, $transaction_id = null, $user = null, $opp_id = null)
    {
        list($response) = $this->crceBundleAdministrationActivateSubscriptionWithHttpInfo($subscription_id, $bundle_code, $correlation_id, $pin, $transaction_id, $user, $opp_id);
        return $response;
    }

    /**
     * Operation crceBundleAdministrationActivateSubscriptionWithHttpInfo
     *
     * activates the given bundle
     *
     * @param int $subscription_id the subscription id (required)
     * @param string $bundle_code the bundle code identifying the bundle that should be activated (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $pin the customer pin, is needed if the customer has enabled security and the request comes from self care (if left empty will not be verified, except for Online Payment use cases) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param int $opp_id the online payment profile ID to use for the payment, if not provided the main balance (e.g. of the prepaid account) will be used for the payment (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return array of \iNew\Rest6_1\Model\ActivateBundleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function crceBundleAdministrationActivateSubscriptionWithHttpInfo($subscription_id, $bundle_code, $correlation_id = null, $pin = null, $transaction_id = null, $user = null, $opp_id = null)
    {
        // verify the required parameter 'subscription_id' is set
        if ($subscription_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $subscription_id when calling crceBundleAdministrationActivateSubscription');
        }
        // verify the required parameter 'bundle_code' is set
        if ($bundle_code === null) {
            throw new \InvalidArgumentException('Missing the required parameter $bundle_code when calling crceBundleAdministrationActivateSubscription');
        }
        // parse inputs
        $resourcePath = "/subscriptions/{subscriptionId}/availableBundles/{bundleCode}/activate";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($opp_id !== null) {
            $queryParams['oppId'] = $this->apiClient->getSerializer()->toQueryValue($opp_id);
        }
        // header params
        if ($correlation_id !== null) {
            $headerParams['correlationId'] = $this->apiClient->getSerializer()->toHeaderValue($correlation_id);
        }
        // header params
        if ($pin !== null) {
            $headerParams['pin'] = $this->apiClient->getSerializer()->toHeaderValue($pin);
        }
        // header params
        if ($transaction_id !== null) {
            $headerParams['transactionId'] = $this->apiClient->getSerializer()->toHeaderValue($transaction_id);
        }
        // header params
        if ($user !== null) {
            $headerParams['user'] = $this->apiClient->getSerializer()->toHeaderValue($user);
        }
        // path params
        if ($subscription_id !== null) {
            $resourcePath = str_replace(
                "{" . "subscriptionId" . "}",
                $this->apiClient->getSerializer()->toPathValue($subscription_id),
                $resourcePath
            );
        }
        // path params
        if ($bundle_code !== null) {
            $resourcePath = str_replace(
                "{" . "bundleCode" . "}",
                $this->apiClient->getSerializer()->toPathValue($bundle_code),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('accessKey');
        if (strlen($apiKey) !== 0) {
            $headerParams['accessKey'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\iNew\Rest6_1\Model\ActivateBundleResponse',
                '/subscriptions/{subscriptionId}/availableBundles/{bundleCode}/activate'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\iNew\Rest6_1\Model\ActivateBundleResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\ActivateBundleResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation crceBundleAdministrationDeactivate
     *
     * deactivates the given bundle
     *
     * @param int $customer_account_id field used to represent the customer identifier, this request is intended for (required)
     * @param int $subscription_id the subscription id (required)
     * @param string $bundle_code the bundleCode identifying the bundle that should be deactivated (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return \iNew\Rest6_1\Model\DeactivateBundleResponse
     */
    public function crceBundleAdministrationDeactivate($customer_account_id, $subscription_id, $bundle_code, $correlation_id = null, $transaction_id = null, $user = null)
    {
        list($response) = $this->crceBundleAdministrationDeactivateWithHttpInfo($customer_account_id, $subscription_id, $bundle_code, $correlation_id, $transaction_id, $user);
        return $response;
    }

    /**
     * Operation crceBundleAdministrationDeactivateWithHttpInfo
     *
     * deactivates the given bundle
     *
     * @param int $customer_account_id field used to represent the customer identifier, this request is intended for (required)
     * @param int $subscription_id the subscription id (required)
     * @param string $bundle_code the bundleCode identifying the bundle that should be deactivated (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return array of \iNew\Rest6_1\Model\DeactivateBundleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function crceBundleAdministrationDeactivateWithHttpInfo($customer_account_id, $subscription_id, $bundle_code, $correlation_id = null, $transaction_id = null, $user = null)
    {
        // verify the required parameter 'customer_account_id' is set
        if ($customer_account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $customer_account_id when calling crceBundleAdministrationDeactivate');
        }
        // verify the required parameter 'subscription_id' is set
        if ($subscription_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $subscription_id when calling crceBundleAdministrationDeactivate');
        }
        // verify the required parameter 'bundle_code' is set
        if ($bundle_code === null) {
            throw new \InvalidArgumentException('Missing the required parameter $bundle_code when calling crceBundleAdministrationDeactivate');
        }
        // parse inputs
        $resourcePath = "/customers/{customerAccountId}/subscriptions/{subscriptionId}/activeBundles/{bundleCode}/deactivate";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // header params
        if ($correlation_id !== null) {
            $headerParams['correlationId'] = $this->apiClient->getSerializer()->toHeaderValue($correlation_id);
        }
        // header params
        if ($transaction_id !== null) {
            $headerParams['transactionId'] = $this->apiClient->getSerializer()->toHeaderValue($transaction_id);
        }
        // header params
        if ($user !== null) {
            $headerParams['user'] = $this->apiClient->getSerializer()->toHeaderValue($user);
        }
        // path params
        if ($customer_account_id !== null) {
            $resourcePath = str_replace(
                "{" . "customerAccountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($customer_account_id),
                $resourcePath
            );
        }
        // path params
        if ($subscription_id !== null) {
            $resourcePath = str_replace(
                "{" . "subscriptionId" . "}",
                $this->apiClient->getSerializer()->toPathValue($subscription_id),
                $resourcePath
            );
        }
        // path params
        if ($bundle_code !== null) {
            $resourcePath = str_replace(
                "{" . "bundleCode" . "}",
                $this->apiClient->getSerializer()->toPathValue($bundle_code),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('accessKey');
        if (strlen($apiKey) !== 0) {
            $headerParams['accessKey'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\iNew\Rest6_1\Model\DeactivateBundleResponse',
                '/customers/{customerAccountId}/subscriptions/{subscriptionId}/activeBundles/{bundleCode}/deactivate'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\iNew\Rest6_1\Model\DeactivateBundleResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\DeactivateBundleResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation crceBundleAdministrationDeactivateSubscription
     *
     * deactivates the given bundle
     *
     * @param int $subscription_id the subscription id (required)
     * @param string $bundle_code the bundleCode identifying the bundle that should be deactivated (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return \iNew\Rest6_1\Model\DeactivateBundleResponse
     */
    public function crceBundleAdministrationDeactivateSubscription($subscription_id, $bundle_code, $correlation_id = null, $transaction_id = null, $user = null)
    {
        list($response) = $this->crceBundleAdministrationDeactivateSubscriptionWithHttpInfo($subscription_id, $bundle_code, $correlation_id, $transaction_id, $user);
        return $response;
    }

    /**
     * Operation crceBundleAdministrationDeactivateSubscriptionWithHttpInfo
     *
     * deactivates the given bundle
     *
     * @param int $subscription_id the subscription id (required)
     * @param string $bundle_code the bundleCode identifying the bundle that should be deactivated (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return array of \iNew\Rest6_1\Model\DeactivateBundleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function crceBundleAdministrationDeactivateSubscriptionWithHttpInfo($subscription_id, $bundle_code, $correlation_id = null, $transaction_id = null, $user = null)
    {
        // verify the required parameter 'subscription_id' is set
        if ($subscription_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $subscription_id when calling crceBundleAdministrationDeactivateSubscription');
        }
        // verify the required parameter 'bundle_code' is set
        if ($bundle_code === null) {
            throw new \InvalidArgumentException('Missing the required parameter $bundle_code when calling crceBundleAdministrationDeactivateSubscription');
        }
        // parse inputs
        $resourcePath = "/subscriptions/{subscriptionId}/activeBundles/{bundleCode}/deactivate";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // header params
        if ($correlation_id !== null) {
            $headerParams['correlationId'] = $this->apiClient->getSerializer()->toHeaderValue($correlation_id);
        }
        // header params
        if ($transaction_id !== null) {
            $headerParams['transactionId'] = $this->apiClient->getSerializer()->toHeaderValue($transaction_id);
        }
        // header params
        if ($user !== null) {
            $headerParams['user'] = $this->apiClient->getSerializer()->toHeaderValue($user);
        }
        // path params
        if ($subscription_id !== null) {
            $resourcePath = str_replace(
                "{" . "subscriptionId" . "}",
                $this->apiClient->getSerializer()->toPathValue($subscription_id),
                $resourcePath
            );
        }
        // path params
        if ($bundle_code !== null) {
            $resourcePath = str_replace(
                "{" . "bundleCode" . "}",
                $this->apiClient->getSerializer()->toPathValue($bundle_code),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('accessKey');
        if (strlen($apiKey) !== 0) {
            $headerParams['accessKey'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\iNew\Rest6_1\Model\DeactivateBundleResponse',
                '/subscriptions/{subscriptionId}/activeBundles/{bundleCode}/deactivate'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\iNew\Rest6_1\Model\DeactivateBundleResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\DeactivateBundleResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation crceBundleAdministrationGet
     *
     * returns the requested bundle
     *
     * @param string $bundle_code the bundle code identifying the bundle that should be returned (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return \iNew\Rest6_1\Model\GetBundleResponse
     */
    public function crceBundleAdministrationGet($bundle_code, $correlation_id = null, $transaction_id = null, $user = null)
    {
        list($response) = $this->crceBundleAdministrationGetWithHttpInfo($bundle_code, $correlation_id, $transaction_id, $user);
        return $response;
    }

    /**
     * Operation crceBundleAdministrationGetWithHttpInfo
     *
     * returns the requested bundle
     *
     * @param string $bundle_code the bundle code identifying the bundle that should be returned (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return array of \iNew\Rest6_1\Model\GetBundleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function crceBundleAdministrationGetWithHttpInfo($bundle_code, $correlation_id = null, $transaction_id = null, $user = null)
    {
        // verify the required parameter 'bundle_code' is set
        if ($bundle_code === null) {
            throw new \InvalidArgumentException('Missing the required parameter $bundle_code when calling crceBundleAdministrationGet');
        }
        // parse inputs
        $resourcePath = "/bundles/code/{bundleCode}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // header params
        if ($correlation_id !== null) {
            $headerParams['correlationId'] = $this->apiClient->getSerializer()->toHeaderValue($correlation_id);
        }
        // header params
        if ($transaction_id !== null) {
            $headerParams['transactionId'] = $this->apiClient->getSerializer()->toHeaderValue($transaction_id);
        }
        // header params
        if ($user !== null) {
            $headerParams['user'] = $this->apiClient->getSerializer()->toHeaderValue($user);
        }
        // path params
        if ($bundle_code !== null) {
            $resourcePath = str_replace(
                "{" . "bundleCode" . "}",
                $this->apiClient->getSerializer()->toPathValue($bundle_code),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('accessKey');
        if (strlen($apiKey) !== 0) {
            $headerParams['accessKey'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\iNew\Rest6_1\Model\GetBundleResponse',
                '/bundles/code/{bundleCode}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\iNew\Rest6_1\Model\GetBundleResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\GetBundleResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation crceBundleAdministrationGetActive
     *
     * returns the activated bundles for the given parameters
     *
     * @param int $customer_account_id field used to represent the customer identifier, this request is intended for (required)
     * @param int $subscription_id the subscription id (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param string $bundle_code the bundle code, if provided the result will be filtered to only show bundles with the provided bundle code (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return \iNew\Rest6_1\Model\GetActivatedBundlesResponse
     */
    public function crceBundleAdministrationGetActive($customer_account_id, $subscription_id, $correlation_id = null, $transaction_id = null, $user = null, $bundle_code = null)
    {
        list($response) = $this->crceBundleAdministrationGetActiveWithHttpInfo($customer_account_id, $subscription_id, $correlation_id, $transaction_id, $user, $bundle_code);
        return $response;
    }

    /**
     * Operation crceBundleAdministrationGetActiveWithHttpInfo
     *
     * returns the activated bundles for the given parameters
     *
     * @param int $customer_account_id field used to represent the customer identifier, this request is intended for (required)
     * @param int $subscription_id the subscription id (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param string $bundle_code the bundle code, if provided the result will be filtered to only show bundles with the provided bundle code (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return array of \iNew\Rest6_1\Model\GetActivatedBundlesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function crceBundleAdministrationGetActiveWithHttpInfo($customer_account_id, $subscription_id, $correlation_id = null, $transaction_id = null, $user = null, $bundle_code = null)
    {
        // verify the required parameter 'customer_account_id' is set
        if ($customer_account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $customer_account_id when calling crceBundleAdministrationGetActive');
        }
        // verify the required parameter 'subscription_id' is set
        if ($subscription_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $subscription_id when calling crceBundleAdministrationGetActive');
        }
        // parse inputs
        $resourcePath = "/customers/{customerAccountId}/subscriptions/{subscriptionId}/activeBundles";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($bundle_code !== null) {
            $queryParams['bundleCode'] = $this->apiClient->getSerializer()->toQueryValue($bundle_code);
        }
        // header params
        if ($correlation_id !== null) {
            $headerParams['correlationId'] = $this->apiClient->getSerializer()->toHeaderValue($correlation_id);
        }
        // header params
        if ($transaction_id !== null) {
            $headerParams['transactionId'] = $this->apiClient->getSerializer()->toHeaderValue($transaction_id);
        }
        // header params
        if ($user !== null) {
            $headerParams['user'] = $this->apiClient->getSerializer()->toHeaderValue($user);
        }
        // path params
        if ($customer_account_id !== null) {
            $resourcePath = str_replace(
                "{" . "customerAccountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($customer_account_id),
                $resourcePath
            );
        }
        // path params
        if ($subscription_id !== null) {
            $resourcePath = str_replace(
                "{" . "subscriptionId" . "}",
                $this->apiClient->getSerializer()->toPathValue($subscription_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('accessKey');
        if (strlen($apiKey) !== 0) {
            $headerParams['accessKey'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\iNew\Rest6_1\Model\GetActivatedBundlesResponse',
                '/customers/{customerAccountId}/subscriptions/{subscriptionId}/activeBundles'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\iNew\Rest6_1\Model\GetActivatedBundlesResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\GetActivatedBundlesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation crceBundleAdministrationGetActiveSubscription
     *
     * returns the activated bundles for the given parameters
     *
     * @param int $subscription_id the subscription id (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param string $bundle_code the bundle code, if provided the result will be filtered to only show bundles with the provided bundle code (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return \iNew\Rest6_1\Model\GetActivatedBundlesResponse
     */
    public function crceBundleAdministrationGetActiveSubscription($subscription_id, $correlation_id = null, $transaction_id = null, $user = null, $bundle_code = null)
    {
        list($response) = $this->crceBundleAdministrationGetActiveSubscriptionWithHttpInfo($subscription_id, $correlation_id, $transaction_id, $user, $bundle_code);
        return $response;
    }

    /**
     * Operation crceBundleAdministrationGetActiveSubscriptionWithHttpInfo
     *
     * returns the activated bundles for the given parameters
     *
     * @param int $subscription_id the subscription id (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param string $bundle_code the bundle code, if provided the result will be filtered to only show bundles with the provided bundle code (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return array of \iNew\Rest6_1\Model\GetActivatedBundlesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function crceBundleAdministrationGetActiveSubscriptionWithHttpInfo($subscription_id, $correlation_id = null, $transaction_id = null, $user = null, $bundle_code = null)
    {
        // verify the required parameter 'subscription_id' is set
        if ($subscription_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $subscription_id when calling crceBundleAdministrationGetActiveSubscription');
        }
        // parse inputs
        $resourcePath = "/subscriptions/{subscriptionId}/activeBundles";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($bundle_code !== null) {
            $queryParams['bundleCode'] = $this->apiClient->getSerializer()->toQueryValue($bundle_code);
        }
        // header params
        if ($correlation_id !== null) {
            $headerParams['correlationId'] = $this->apiClient->getSerializer()->toHeaderValue($correlation_id);
        }
        // header params
        if ($transaction_id !== null) {
            $headerParams['transactionId'] = $this->apiClient->getSerializer()->toHeaderValue($transaction_id);
        }
        // header params
        if ($user !== null) {
            $headerParams['user'] = $this->apiClient->getSerializer()->toHeaderValue($user);
        }
        // path params
        if ($subscription_id !== null) {
            $resourcePath = str_replace(
                "{" . "subscriptionId" . "}",
                $this->apiClient->getSerializer()->toPathValue($subscription_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('accessKey');
        if (strlen($apiKey) !== 0) {
            $headerParams['accessKey'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\iNew\Rest6_1\Model\GetActivatedBundlesResponse',
                '/subscriptions/{subscriptionId}/activeBundles'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\iNew\Rest6_1\Model\GetActivatedBundlesResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\GetActivatedBundlesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation crceBundleAdministrationGetAvailable
     *
     * returns the available bundles
     *
     * @param int $customer_account_id field used to represent the customer identifier, this request is intended for (required)
     * @param int $subscription_id the subscription id (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param int $entities_per_page the number of entities that should be returned per page (pagination) (optional)
     * @param string $group_code the group code, if provided the result of this request will be filtered to only show bundles for the provided group code (optional)
     * @param int $page the page requested (pagination) (optional)
     * @param string $payment_option the payment option, if provided the result of this request will be filtered to only show bundles which can be paid for with the provided payment method (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return \iNew\Rest6_1\Model\GetAvailableBundlesResponse
     */
    public function crceBundleAdministrationGetAvailable($customer_account_id, $subscription_id, $correlation_id = null, $transaction_id = null, $user = null, $entities_per_page = null, $group_code = null, $page = null, $payment_option = null)
    {
        list($response) = $this->crceBundleAdministrationGetAvailableWithHttpInfo($customer_account_id, $subscription_id, $correlation_id, $transaction_id, $user, $entities_per_page, $group_code, $page, $payment_option);
        return $response;
    }

    /**
     * Operation crceBundleAdministrationGetAvailableWithHttpInfo
     *
     * returns the available bundles
     *
     * @param int $customer_account_id field used to represent the customer identifier, this request is intended for (required)
     * @param int $subscription_id the subscription id (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param int $entities_per_page the number of entities that should be returned per page (pagination) (optional)
     * @param string $group_code the group code, if provided the result of this request will be filtered to only show bundles for the provided group code (optional)
     * @param int $page the page requested (pagination) (optional)
     * @param string $payment_option the payment option, if provided the result of this request will be filtered to only show bundles which can be paid for with the provided payment method (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return array of \iNew\Rest6_1\Model\GetAvailableBundlesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function crceBundleAdministrationGetAvailableWithHttpInfo($customer_account_id, $subscription_id, $correlation_id = null, $transaction_id = null, $user = null, $entities_per_page = null, $group_code = null, $page = null, $payment_option = null)
    {
        // verify the required parameter 'customer_account_id' is set
        if ($customer_account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $customer_account_id when calling crceBundleAdministrationGetAvailable');
        }
        // verify the required parameter 'subscription_id' is set
        if ($subscription_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $subscription_id when calling crceBundleAdministrationGetAvailable');
        }
        // parse inputs
        $resourcePath = "/customers/{customerAccountId}/subscriptions/{subscriptionId}/availableBundles";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($entities_per_page !== null) {
            $queryParams['entitiesPerPage'] = $this->apiClient->getSerializer()->toQueryValue($entities_per_page);
        }
        // query params
        if ($group_code !== null) {
            $queryParams['groupCode'] = $this->apiClient->getSerializer()->toQueryValue($group_code);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = $this->apiClient->getSerializer()->toQueryValue($page);
        }
        // query params
        if ($payment_option !== null) {
            $queryParams['paymentOption'] = $this->apiClient->getSerializer()->toQueryValue($payment_option);
        }
        // header params
        if ($correlation_id !== null) {
            $headerParams['correlationId'] = $this->apiClient->getSerializer()->toHeaderValue($correlation_id);
        }
        // header params
        if ($transaction_id !== null) {
            $headerParams['transactionId'] = $this->apiClient->getSerializer()->toHeaderValue($transaction_id);
        }
        // header params
        if ($user !== null) {
            $headerParams['user'] = $this->apiClient->getSerializer()->toHeaderValue($user);
        }
        // path params
        if ($customer_account_id !== null) {
            $resourcePath = str_replace(
                "{" . "customerAccountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($customer_account_id),
                $resourcePath
            );
        }
        // path params
        if ($subscription_id !== null) {
            $resourcePath = str_replace(
                "{" . "subscriptionId" . "}",
                $this->apiClient->getSerializer()->toPathValue($subscription_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('accessKey');
        if (strlen($apiKey) !== 0) {
            $headerParams['accessKey'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\iNew\Rest6_1\Model\GetAvailableBundlesResponse',
                '/customers/{customerAccountId}/subscriptions/{subscriptionId}/availableBundles'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\iNew\Rest6_1\Model\GetAvailableBundlesResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\GetAvailableBundlesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation crceBundleAdministrationGetAvailableSubscription
     *
     * returns the available bundles
     *
     * @param int $subscription_id the subscription id (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param int $entities_per_page the number of entities that should be returned per page (pagination) (optional)
     * @param string $group_code the group code, if provided the result of this request will be filtered to only show bundles for the provided group code (optional)
     * @param int $page the page requested (pagination) (optional)
     * @param string $payment_option the payment option, if provided the result of this request will be filtered to only show bundles which can be paid for with the provided payment method (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return \iNew\Rest6_1\Model\GetAvailableBundlesResponse
     */
    public function crceBundleAdministrationGetAvailableSubscription($subscription_id, $correlation_id = null, $transaction_id = null, $user = null, $entities_per_page = null, $group_code = null, $page = null, $payment_option = null)
    {
        list($response) = $this->crceBundleAdministrationGetAvailableSubscriptionWithHttpInfo($subscription_id, $correlation_id, $transaction_id, $user, $entities_per_page, $group_code, $page, $payment_option);
        return $response;
    }

    /**
     * Operation crceBundleAdministrationGetAvailableSubscriptionWithHttpInfo
     *
     * returns the available bundles
     *
     * @param int $subscription_id the subscription id (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param int $entities_per_page the number of entities that should be returned per page (pagination) (optional)
     * @param string $group_code the group code, if provided the result of this request will be filtered to only show bundles for the provided group code (optional)
     * @param int $page the page requested (pagination) (optional)
     * @param string $payment_option the payment option, if provided the result of this request will be filtered to only show bundles which can be paid for with the provided payment method (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return array of \iNew\Rest6_1\Model\GetAvailableBundlesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function crceBundleAdministrationGetAvailableSubscriptionWithHttpInfo($subscription_id, $correlation_id = null, $transaction_id = null, $user = null, $entities_per_page = null, $group_code = null, $page = null, $payment_option = null)
    {
        // verify the required parameter 'subscription_id' is set
        if ($subscription_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $subscription_id when calling crceBundleAdministrationGetAvailableSubscription');
        }
        // parse inputs
        $resourcePath = "/subscriptions/{subscriptionId}/availableBundles";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($entities_per_page !== null) {
            $queryParams['entitiesPerPage'] = $this->apiClient->getSerializer()->toQueryValue($entities_per_page);
        }
        // query params
        if ($group_code !== null) {
            $queryParams['groupCode'] = $this->apiClient->getSerializer()->toQueryValue($group_code);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = $this->apiClient->getSerializer()->toQueryValue($page);
        }
        // query params
        if ($payment_option !== null) {
            $queryParams['paymentOption'] = $this->apiClient->getSerializer()->toQueryValue($payment_option);
        }
        // header params
        if ($correlation_id !== null) {
            $headerParams['correlationId'] = $this->apiClient->getSerializer()->toHeaderValue($correlation_id);
        }
        // header params
        if ($transaction_id !== null) {
            $headerParams['transactionId'] = $this->apiClient->getSerializer()->toHeaderValue($transaction_id);
        }
        // header params
        if ($user !== null) {
            $headerParams['user'] = $this->apiClient->getSerializer()->toHeaderValue($user);
        }
        // path params
        if ($subscription_id !== null) {
            $resourcePath = str_replace(
                "{" . "subscriptionId" . "}",
                $this->apiClient->getSerializer()->toPathValue($subscription_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('accessKey');
        if (strlen($apiKey) !== 0) {
            $headerParams['accessKey'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\iNew\Rest6_1\Model\GetAvailableBundlesResponse',
                '/subscriptions/{subscriptionId}/availableBundles'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\iNew\Rest6_1\Model\GetAvailableBundlesResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\GetAvailableBundlesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation crceBundleAdministrationGetAvailableTariff
     *
     * returns the available bundles
     *
     * @param int $tariff_id the tariff ID for which the available bundles should be listed (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param int $entities_per_page the number of entities that should be returned per page (pagination) (optional)
     * @param string $group_code the group code, if provided the result of this request will be filtered to only show bundles for the provided group code (optional)
     * @param int $page the page requested (pagination) (optional)
     * @param string $payment_option the payment option, if provided the result of this request will be filtered to only show bundles which can be paid for with the provided payment method (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return \iNew\Rest6_1\Model\GetAvailableBundlesResponse
     */
    public function crceBundleAdministrationGetAvailableTariff($tariff_id, $correlation_id = null, $transaction_id = null, $user = null, $entities_per_page = null, $group_code = null, $page = null, $payment_option = null)
    {
        list($response) = $this->crceBundleAdministrationGetAvailableTariffWithHttpInfo($tariff_id, $correlation_id, $transaction_id, $user, $entities_per_page, $group_code, $page, $payment_option);
        return $response;
    }

    /**
     * Operation crceBundleAdministrationGetAvailableTariffWithHttpInfo
     *
     * returns the available bundles
     *
     * @param int $tariff_id the tariff ID for which the available bundles should be listed (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param int $entities_per_page the number of entities that should be returned per page (pagination) (optional)
     * @param string $group_code the group code, if provided the result of this request will be filtered to only show bundles for the provided group code (optional)
     * @param int $page the page requested (pagination) (optional)
     * @param string $payment_option the payment option, if provided the result of this request will be filtered to only show bundles which can be paid for with the provided payment method (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return array of \iNew\Rest6_1\Model\GetAvailableBundlesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function crceBundleAdministrationGetAvailableTariffWithHttpInfo($tariff_id, $correlation_id = null, $transaction_id = null, $user = null, $entities_per_page = null, $group_code = null, $page = null, $payment_option = null)
    {
        // verify the required parameter 'tariff_id' is set
        if ($tariff_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $tariff_id when calling crceBundleAdministrationGetAvailableTariff');
        }
        // parse inputs
        $resourcePath = "/tariffs/{tariffId}/availableBundles";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($entities_per_page !== null) {
            $queryParams['entitiesPerPage'] = $this->apiClient->getSerializer()->toQueryValue($entities_per_page);
        }
        // query params
        if ($group_code !== null) {
            $queryParams['groupCode'] = $this->apiClient->getSerializer()->toQueryValue($group_code);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = $this->apiClient->getSerializer()->toQueryValue($page);
        }
        // query params
        if ($payment_option !== null) {
            $queryParams['paymentOption'] = $this->apiClient->getSerializer()->toQueryValue($payment_option);
        }
        // header params
        if ($correlation_id !== null) {
            $headerParams['correlationId'] = $this->apiClient->getSerializer()->toHeaderValue($correlation_id);
        }
        // header params
        if ($transaction_id !== null) {
            $headerParams['transactionId'] = $this->apiClient->getSerializer()->toHeaderValue($transaction_id);
        }
        // header params
        if ($user !== null) {
            $headerParams['user'] = $this->apiClient->getSerializer()->toHeaderValue($user);
        }
        // path params
        if ($tariff_id !== null) {
            $resourcePath = str_replace(
                "{" . "tariffId" . "}",
                $this->apiClient->getSerializer()->toPathValue($tariff_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('accessKey');
        if (strlen($apiKey) !== 0) {
            $headerParams['accessKey'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\iNew\Rest6_1\Model\GetAvailableBundlesResponse',
                '/tariffs/{tariffId}/availableBundles'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\iNew\Rest6_1\Model\GetAvailableBundlesResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\GetAvailableBundlesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation crceBundleAdministrationGetBonus
     *
     * returns the available bonus bundles
     *
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param int $entities_per_page the number of entities that should be returned per page (pagination) (optional)
     * @param int $page the page requested (pagination) (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return \iNew\Rest6_1\Model\GetAvailableBundlesResponse
     */
    public function crceBundleAdministrationGetBonus($correlation_id = null, $transaction_id = null, $user = null, $entities_per_page = null, $page = null)
    {
        list($response) = $this->crceBundleAdministrationGetBonusWithHttpInfo($correlation_id, $transaction_id, $user, $entities_per_page, $page);
        return $response;
    }

    /**
     * Operation crceBundleAdministrationGetBonusWithHttpInfo
     *
     * returns the available bonus bundles
     *
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param int $entities_per_page the number of entities that should be returned per page (pagination) (optional)
     * @param int $page the page requested (pagination) (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return array of \iNew\Rest6_1\Model\GetAvailableBundlesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function crceBundleAdministrationGetBonusWithHttpInfo($correlation_id = null, $transaction_id = null, $user = null, $entities_per_page = null, $page = null)
    {
        // parse inputs
        $resourcePath = "/bundles/bonus";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($entities_per_page !== null) {
            $queryParams['entitiesPerPage'] = $this->apiClient->getSerializer()->toQueryValue($entities_per_page);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = $this->apiClient->getSerializer()->toQueryValue($page);
        }
        // header params
        if ($correlation_id !== null) {
            $headerParams['correlationId'] = $this->apiClient->getSerializer()->toHeaderValue($correlation_id);
        }
        // header params
        if ($transaction_id !== null) {
            $headerParams['transactionId'] = $this->apiClient->getSerializer()->toHeaderValue($transaction_id);
        }
        // header params
        if ($user !== null) {
            $headerParams['user'] = $this->apiClient->getSerializer()->toHeaderValue($user);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('accessKey');
        if (strlen($apiKey) !== 0) {
            $headerParams['accessKey'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\iNew\Rest6_1\Model\GetAvailableBundlesResponse',
                '/bundles/bonus'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\iNew\Rest6_1\Model\GetAvailableBundlesResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\GetAvailableBundlesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation crceBundleAdministrationGetByReferenceId
     *
     * returns the requested bundle
     *
     * @param int $id the referenceId identifying the bundle that should be returned (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return \iNew\Rest6_1\Model\GetBundleResponse
     */
    public function crceBundleAdministrationGetByReferenceId($id, $correlation_id = null, $transaction_id = null, $user = null)
    {
        list($response) = $this->crceBundleAdministrationGetByReferenceIdWithHttpInfo($id, $correlation_id, $transaction_id, $user);
        return $response;
    }

    /**
     * Operation crceBundleAdministrationGetByReferenceIdWithHttpInfo
     *
     * returns the requested bundle
     *
     * @param int $id the referenceId identifying the bundle that should be returned (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return array of \iNew\Rest6_1\Model\GetBundleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function crceBundleAdministrationGetByReferenceIdWithHttpInfo($id, $correlation_id = null, $transaction_id = null, $user = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling crceBundleAdministrationGetByReferenceId');
        }
        // parse inputs
        $resourcePath = "/bundles/reference/{id}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // header params
        if ($correlation_id !== null) {
            $headerParams['correlationId'] = $this->apiClient->getSerializer()->toHeaderValue($correlation_id);
        }
        // header params
        if ($transaction_id !== null) {
            $headerParams['transactionId'] = $this->apiClient->getSerializer()->toHeaderValue($transaction_id);
        }
        // header params
        if ($user !== null) {
            $headerParams['user'] = $this->apiClient->getSerializer()->toHeaderValue($user);
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                $this->apiClient->getSerializer()->toPathValue($id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('accessKey');
        if (strlen($apiKey) !== 0) {
            $headerParams['accessKey'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\iNew\Rest6_1\Model\GetBundleResponse',
                '/bundles/reference/{id}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\iNew\Rest6_1\Model\GetBundleResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\GetBundleResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation crceBundleAdministrationGetGroups
     *
     * returns the requested bundle groups or subgroups if a groupCode was provided
     *
     * @param int $tariff_id the tariffId, for which bundle groups should be returned (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param string $group_code the group code, of which subgroups should be returned (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return \iNew\Rest6_1\Model\GetBundleGroupsResponse
     */
    public function crceBundleAdministrationGetGroups($tariff_id, $correlation_id = null, $transaction_id = null, $user = null, $group_code = null)
    {
        list($response) = $this->crceBundleAdministrationGetGroupsWithHttpInfo($tariff_id, $correlation_id, $transaction_id, $user, $group_code);
        return $response;
    }

    /**
     * Operation crceBundleAdministrationGetGroupsWithHttpInfo
     *
     * returns the requested bundle groups or subgroups if a groupCode was provided
     *
     * @param int $tariff_id the tariffId, for which bundle groups should be returned (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param string $group_code the group code, of which subgroups should be returned (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return array of \iNew\Rest6_1\Model\GetBundleGroupsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function crceBundleAdministrationGetGroupsWithHttpInfo($tariff_id, $correlation_id = null, $transaction_id = null, $user = null, $group_code = null)
    {
        // verify the required parameter 'tariff_id' is set
        if ($tariff_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $tariff_id when calling crceBundleAdministrationGetGroups');
        }
        // parse inputs
        $resourcePath = "/tariffs/{tariffId}/bundleGroups";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($group_code !== null) {
            $queryParams['groupCode'] = $this->apiClient->getSerializer()->toQueryValue($group_code);
        }
        // header params
        if ($correlation_id !== null) {
            $headerParams['correlationId'] = $this->apiClient->getSerializer()->toHeaderValue($correlation_id);
        }
        // header params
        if ($transaction_id !== null) {
            $headerParams['transactionId'] = $this->apiClient->getSerializer()->toHeaderValue($transaction_id);
        }
        // header params
        if ($user !== null) {
            $headerParams['user'] = $this->apiClient->getSerializer()->toHeaderValue($user);
        }
        // path params
        if ($tariff_id !== null) {
            $resourcePath = str_replace(
                "{" . "tariffId" . "}",
                $this->apiClient->getSerializer()->toPathValue($tariff_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('accessKey');
        if (strlen($apiKey) !== 0) {
            $headerParams['accessKey'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\iNew\Rest6_1\Model\GetBundleGroupsResponse',
                '/tariffs/{tariffId}/bundleGroups'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\iNew\Rest6_1\Model\GetBundleGroupsResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\GetBundleGroupsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation crceOnlinePaymentUpdateBundle
     *
     * updates the payment method for the given bundle
     *
     * @param int $customer_account_id field used to represent the customer identifier, this request is intended for (required)
     * @param int $subscription_id the subscription id (required)
     * @param string $bundle_code the bundle code identifying the bundle that should be updated (required)
     * @param \iNew\Rest6_1\Model\PaymentMethod $payment the payment method that should be used (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $pin the customer pin, is needed if the customer has enabled security and the request comes from self care (if left empty will not be verified, except for Online Payment use cases) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return \iNew\Rest6_1\Model\UpdateBundleResponse
     */
    public function crceOnlinePaymentUpdateBundle($customer_account_id, $subscription_id, $bundle_code, $payment, $correlation_id = null, $pin = null, $transaction_id = null, $user = null)
    {
        list($response) = $this->crceOnlinePaymentUpdateBundleWithHttpInfo($customer_account_id, $subscription_id, $bundle_code, $payment, $correlation_id, $pin, $transaction_id, $user);
        return $response;
    }

    /**
     * Operation crceOnlinePaymentUpdateBundleWithHttpInfo
     *
     * updates the payment method for the given bundle
     *
     * @param int $customer_account_id field used to represent the customer identifier, this request is intended for (required)
     * @param int $subscription_id the subscription id (required)
     * @param string $bundle_code the bundle code identifying the bundle that should be updated (required)
     * @param \iNew\Rest6_1\Model\PaymentMethod $payment the payment method that should be used (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $pin the customer pin, is needed if the customer has enabled security and the request comes from self care (if left empty will not be verified, except for Online Payment use cases) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return array of \iNew\Rest6_1\Model\UpdateBundleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function crceOnlinePaymentUpdateBundleWithHttpInfo($customer_account_id, $subscription_id, $bundle_code, $payment, $correlation_id = null, $pin = null, $transaction_id = null, $user = null)
    {
        // verify the required parameter 'customer_account_id' is set
        if ($customer_account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $customer_account_id when calling crceOnlinePaymentUpdateBundle');
        }
        // verify the required parameter 'subscription_id' is set
        if ($subscription_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $subscription_id when calling crceOnlinePaymentUpdateBundle');
        }
        // verify the required parameter 'bundle_code' is set
        if ($bundle_code === null) {
            throw new \InvalidArgumentException('Missing the required parameter $bundle_code when calling crceOnlinePaymentUpdateBundle');
        }
        // verify the required parameter 'payment' is set
        if ($payment === null) {
            throw new \InvalidArgumentException('Missing the required parameter $payment when calling crceOnlinePaymentUpdateBundle');
        }
        // parse inputs
        $resourcePath = "/customers/{customerAccountId}/subscriptions/{subscriptionId}/activeBundles/{bundleCode}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // header params
        if ($correlation_id !== null) {
            $headerParams['correlationId'] = $this->apiClient->getSerializer()->toHeaderValue($correlation_id);
        }
        // header params
        if ($pin !== null) {
            $headerParams['pin'] = $this->apiClient->getSerializer()->toHeaderValue($pin);
        }
        // header params
        if ($transaction_id !== null) {
            $headerParams['transactionId'] = $this->apiClient->getSerializer()->toHeaderValue($transaction_id);
        }
        // header params
        if ($user !== null) {
            $headerParams['user'] = $this->apiClient->getSerializer()->toHeaderValue($user);
        }
        // path params
        if ($customer_account_id !== null) {
            $resourcePath = str_replace(
                "{" . "customerAccountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($customer_account_id),
                $resourcePath
            );
        }
        // path params
        if ($subscription_id !== null) {
            $resourcePath = str_replace(
                "{" . "subscriptionId" . "}",
                $this->apiClient->getSerializer()->toPathValue($subscription_id),
                $resourcePath
            );
        }
        // path params
        if ($bundle_code !== null) {
            $resourcePath = str_replace(
                "{" . "bundleCode" . "}",
                $this->apiClient->getSerializer()->toPathValue($bundle_code),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($payment)) {
            $_tempBody = $payment;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('accessKey');
        if (strlen($apiKey) !== 0) {
            $headerParams['accessKey'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\iNew\Rest6_1\Model\UpdateBundleResponse',
                '/customers/{customerAccountId}/subscriptions/{subscriptionId}/activeBundles/{bundleCode}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\iNew\Rest6_1\Model\UpdateBundleResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\UpdateBundleResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation crceOnlinePaymentUpdateBundleSubscription
     *
     * updates the payment method for the given bundle
     *
     * @param int $subscription_id the subscription id (required)
     * @param string $bundle_code the bundle code identifying the bundle that should be updated (required)
     * @param \iNew\Rest6_1\Model\PaymentMethod $payment the payment method that should be used (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $pin the customer pin, is needed if the customer has enabled security and the request comes from self care (if left empty will not be verified, except for Online Payment use cases) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return \iNew\Rest6_1\Model\UpdateBundleResponse
     */
    public function crceOnlinePaymentUpdateBundleSubscription($subscription_id, $bundle_code, $payment, $correlation_id = null, $pin = null, $transaction_id = null, $user = null)
    {
        list($response) = $this->crceOnlinePaymentUpdateBundleSubscriptionWithHttpInfo($subscription_id, $bundle_code, $payment, $correlation_id, $pin, $transaction_id, $user);
        return $response;
    }

    /**
     * Operation crceOnlinePaymentUpdateBundleSubscriptionWithHttpInfo
     *
     * updates the payment method for the given bundle
     *
     * @param int $subscription_id the subscription id (required)
     * @param string $bundle_code the bundle code identifying the bundle that should be updated (required)
     * @param \iNew\Rest6_1\Model\PaymentMethod $payment the payment method that should be used (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $pin the customer pin, is needed if the customer has enabled security and the request comes from self care (if left empty will not be verified, except for Online Payment use cases) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return array of \iNew\Rest6_1\Model\UpdateBundleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function crceOnlinePaymentUpdateBundleSubscriptionWithHttpInfo($subscription_id, $bundle_code, $payment, $correlation_id = null, $pin = null, $transaction_id = null, $user = null)
    {
        // verify the required parameter 'subscription_id' is set
        if ($subscription_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $subscription_id when calling crceOnlinePaymentUpdateBundleSubscription');
        }
        // verify the required parameter 'bundle_code' is set
        if ($bundle_code === null) {
            throw new \InvalidArgumentException('Missing the required parameter $bundle_code when calling crceOnlinePaymentUpdateBundleSubscription');
        }
        // verify the required parameter 'payment' is set
        if ($payment === null) {
            throw new \InvalidArgumentException('Missing the required parameter $payment when calling crceOnlinePaymentUpdateBundleSubscription');
        }
        // parse inputs
        $resourcePath = "/subscriptions/{subscriptionId}/activeBundles/{bundleCode}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // header params
        if ($correlation_id !== null) {
            $headerParams['correlationId'] = $this->apiClient->getSerializer()->toHeaderValue($correlation_id);
        }
        // header params
        if ($pin !== null) {
            $headerParams['pin'] = $this->apiClient->getSerializer()->toHeaderValue($pin);
        }
        // header params
        if ($transaction_id !== null) {
            $headerParams['transactionId'] = $this->apiClient->getSerializer()->toHeaderValue($transaction_id);
        }
        // header params
        if ($user !== null) {
            $headerParams['user'] = $this->apiClient->getSerializer()->toHeaderValue($user);
        }
        // path params
        if ($subscription_id !== null) {
            $resourcePath = str_replace(
                "{" . "subscriptionId" . "}",
                $this->apiClient->getSerializer()->toPathValue($subscription_id),
                $resourcePath
            );
        }
        // path params
        if ($bundle_code !== null) {
            $resourcePath = str_replace(
                "{" . "bundleCode" . "}",
                $this->apiClient->getSerializer()->toPathValue($bundle_code),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($payment)) {
            $_tempBody = $payment;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('accessKey');
        if (strlen($apiKey) !== 0) {
            $headerParams['accessKey'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\iNew\Rest6_1\Model\UpdateBundleResponse',
                '/subscriptions/{subscriptionId}/activeBundles/{bundleCode}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\iNew\Rest6_1\Model\UpdateBundleResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\UpdateBundleResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation rtmRetailManagerActivateBundle
     *
     * activates the given bundle
     *
     * @param string $msisdn The phone number of the subscriber (required)
     * @param string $bundle_code the product ID of the bundle/plan that should be activated (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param string $pos_id the the ID identifying the point of sale e.g. a specific terminal, can be used to track whoever authorized the transaction in more detail (the retailer ID will definitely be part of the transaction since it is encoded in the access key) (optional)
     * @param string $sub_retailer_id the ID identifying the sub retailer e.g. a subsidiary company, can be used to track whoever authorized the transaction in more detail (the retailer ID will definitely be part of the transaction since it is encoded in the access key) (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return \iNew\Rest6_1\Model\ChargeResponse
     */
    public function rtmRetailManagerActivateBundle($msisdn, $bundle_code, $correlation_id = null, $transaction_id = null, $user = null, $pos_id = null, $sub_retailer_id = null)
    {
        list($response) = $this->rtmRetailManagerActivateBundleWithHttpInfo($msisdn, $bundle_code, $correlation_id, $transaction_id, $user, $pos_id, $sub_retailer_id);
        return $response;
    }

    /**
     * Operation rtmRetailManagerActivateBundleWithHttpInfo
     *
     * activates the given bundle
     *
     * @param string $msisdn The phone number of the subscriber (required)
     * @param string $bundle_code the product ID of the bundle/plan that should be activated (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param string $pos_id the the ID identifying the point of sale e.g. a specific terminal, can be used to track whoever authorized the transaction in more detail (the retailer ID will definitely be part of the transaction since it is encoded in the access key) (optional)
     * @param string $sub_retailer_id the ID identifying the sub retailer e.g. a subsidiary company, can be used to track whoever authorized the transaction in more detail (the retailer ID will definitely be part of the transaction since it is encoded in the access key) (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return array of \iNew\Rest6_1\Model\ChargeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function rtmRetailManagerActivateBundleWithHttpInfo($msisdn, $bundle_code, $correlation_id = null, $transaction_id = null, $user = null, $pos_id = null, $sub_retailer_id = null)
    {
        // verify the required parameter 'msisdn' is set
        if ($msisdn === null) {
            throw new \InvalidArgumentException('Missing the required parameter $msisdn when calling rtmRetailManagerActivateBundle');
        }
        // verify the required parameter 'bundle_code' is set
        if ($bundle_code === null) {
            throw new \InvalidArgumentException('Missing the required parameter $bundle_code when calling rtmRetailManagerActivateBundle');
        }
        // parse inputs
        $resourcePath = "/retailer/{msisdn}/availableBundles/{bundleCode}/activate";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($pos_id !== null) {
            $queryParams['posId'] = $this->apiClient->getSerializer()->toQueryValue($pos_id);
        }
        // query params
        if ($sub_retailer_id !== null) {
            $queryParams['subRetailerId'] = $this->apiClient->getSerializer()->toQueryValue($sub_retailer_id);
        }
        // header params
        if ($correlation_id !== null) {
            $headerParams['correlationId'] = $this->apiClient->getSerializer()->toHeaderValue($correlation_id);
        }
        // header params
        if ($transaction_id !== null) {
            $headerParams['transactionId'] = $this->apiClient->getSerializer()->toHeaderValue($transaction_id);
        }
        // header params
        if ($user !== null) {
            $headerParams['user'] = $this->apiClient->getSerializer()->toHeaderValue($user);
        }
        // path params
        if ($msisdn !== null) {
            $resourcePath = str_replace(
                "{" . "msisdn" . "}",
                $this->apiClient->getSerializer()->toPathValue($msisdn),
                $resourcePath
            );
        }
        // path params
        if ($bundle_code !== null) {
            $resourcePath = str_replace(
                "{" . "bundleCode" . "}",
                $this->apiClient->getSerializer()->toPathValue($bundle_code),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('accessKey');
        if (strlen($apiKey) !== 0) {
            $headerParams['accessKey'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\iNew\Rest6_1\Model\ChargeResponse',
                '/retailer/{msisdn}/availableBundles/{bundleCode}/activate'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\iNew\Rest6_1\Model\ChargeResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\ChargeResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation rtmRetailManagerGetAvailableBundles
     *
     * returns the available bundles
     *
     * @param string $msisdn The phone number of the subscriber (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param int $entities_per_page the number of entities that should be returned per page (pagination) (optional)
     * @param string $group_code the group code, if provided the result of this request will be filtered to only show bundles for the provided group code (optional)
     * @param int $page the page requested (pagination) (optional)
     * @param string $pos_id the the ID identifying the point of sale e.g. a specific terminal, can be used to track whoever authorized the transaction in more detail (the retailer ID will definitely be part of the transaction since it is encoded in the access key) (optional)
     * @param string $sub_retailer_id the ID identifying the sub retailer e.g. a subsidiary company, can be used to track whoever authorized the transaction in more detail (the retailer ID will definitely be part of the transaction since it is encoded in the access key) (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return \iNew\Rest6_1\Model\GetAvailableBundlesResponse1
     */
    public function rtmRetailManagerGetAvailableBundles($msisdn, $correlation_id = null, $transaction_id = null, $user = null, $entities_per_page = null, $group_code = null, $page = null, $pos_id = null, $sub_retailer_id = null)
    {
        list($response) = $this->rtmRetailManagerGetAvailableBundlesWithHttpInfo($msisdn, $correlation_id, $transaction_id, $user, $entities_per_page, $group_code, $page, $pos_id, $sub_retailer_id);
        return $response;
    }

    /**
     * Operation rtmRetailManagerGetAvailableBundlesWithHttpInfo
     *
     * returns the available bundles
     *
     * @param string $msisdn The phone number of the subscriber (required)
     * @param string $correlation_id the correlation ID, to match a response with this request (will be generated if not provided) (optional)
     * @param string $transaction_id the transaction ID, if this request is part of a transaction that needs to be traceable (optional)
     * @param string $user the user making the request (optional)
     * @param int $entities_per_page the number of entities that should be returned per page (pagination) (optional)
     * @param string $group_code the group code, if provided the result of this request will be filtered to only show bundles for the provided group code (optional)
     * @param int $page the page requested (pagination) (optional)
     * @param string $pos_id the the ID identifying the point of sale e.g. a specific terminal, can be used to track whoever authorized the transaction in more detail (the retailer ID will definitely be part of the transaction since it is encoded in the access key) (optional)
     * @param string $sub_retailer_id the ID identifying the sub retailer e.g. a subsidiary company, can be used to track whoever authorized the transaction in more detail (the retailer ID will definitely be part of the transaction since it is encoded in the access key) (optional)
     * @throws \iNew\Rest6_1\ApiException on non-2xx response
     * @return array of \iNew\Rest6_1\Model\GetAvailableBundlesResponse1, HTTP status code, HTTP response headers (array of strings)
     */
    public function rtmRetailManagerGetAvailableBundlesWithHttpInfo($msisdn, $correlation_id = null, $transaction_id = null, $user = null, $entities_per_page = null, $group_code = null, $page = null, $pos_id = null, $sub_retailer_id = null)
    {
        // verify the required parameter 'msisdn' is set
        if ($msisdn === null) {
            throw new \InvalidArgumentException('Missing the required parameter $msisdn when calling rtmRetailManagerGetAvailableBundles');
        }
        // parse inputs
        $resourcePath = "/retailer/{msisdn}/availableBundles";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($entities_per_page !== null) {
            $queryParams['entitiesPerPage'] = $this->apiClient->getSerializer()->toQueryValue($entities_per_page);
        }
        // query params
        if ($group_code !== null) {
            $queryParams['groupCode'] = $this->apiClient->getSerializer()->toQueryValue($group_code);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = $this->apiClient->getSerializer()->toQueryValue($page);
        }
        // query params
        if ($pos_id !== null) {
            $queryParams['posId'] = $this->apiClient->getSerializer()->toQueryValue($pos_id);
        }
        // query params
        if ($sub_retailer_id !== null) {
            $queryParams['subRetailerId'] = $this->apiClient->getSerializer()->toQueryValue($sub_retailer_id);
        }
        // header params
        if ($correlation_id !== null) {
            $headerParams['correlationId'] = $this->apiClient->getSerializer()->toHeaderValue($correlation_id);
        }
        // header params
        if ($transaction_id !== null) {
            $headerParams['transactionId'] = $this->apiClient->getSerializer()->toHeaderValue($transaction_id);
        }
        // header params
        if ($user !== null) {
            $headerParams['user'] = $this->apiClient->getSerializer()->toHeaderValue($user);
        }
        // path params
        if ($msisdn !== null) {
            $resourcePath = str_replace(
                "{" . "msisdn" . "}",
                $this->apiClient->getSerializer()->toPathValue($msisdn),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('accessKey');
        if (strlen($apiKey) !== 0) {
            $headerParams['accessKey'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\iNew\Rest6_1\Model\GetAvailableBundlesResponse1',
                '/retailer/{msisdn}/availableBundles'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\iNew\Rest6_1\Model\GetAvailableBundlesResponse1', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\GetAvailableBundlesResponse1', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\iNew\Rest6_1\Model\RestError', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }
}
